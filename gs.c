#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <mpi.h>
#include <time.h>

#define VERBOSE 0

/***** Globals ******/
float **a; /* The coefficients */
float *contiguousA; // Just a copy of "a", but in a continuous memory space.
float *x;  /* The unknowns */
float *b;  /* The constants */
float err; /* The absolute relative error */
int maxIter;
int num = 0;  /* number of unknowns */


/****** Function declarations */
void check_matrix(); /* Check whether the matrix will converge */
int* compute_chunk_displacement(int matrixSize, int numProc, int *sizes, int matrix);
int* compute_size_array(int matrixSize, int numProc, int matrix);
float calculate_error(float *xOld, float *xNew, int num);
void get_input();  /* Read input from file */

/********************************/

/* 
   Conditions for convergence (diagonal dominance):
   1. diagonal element >= sum of all other elements of the row
   2. At least one diagonal element > sum of all other elements of the row
 */
void check_matrix()
{
  int bigger = 0; /* Set to 1 if at least one diag element > sum  */
  int i, j;
  float sum = 0;
  float aii = 0;
  
  for(i = 0; i < num; i++)
  {
    sum = 0;
    aii = fabs(a[i][i]);
    
    for(j = 0; j < num; j++)
       if( j != i)
	 sum += fabs(a[i][j]);
       
    if( aii < sum)
    {
      printf("The matrix will not converge\n");
      exit(1);
    }
    
    if(aii > sum)
      bigger++;
    
  }
  
  if( !bigger )
  {
     printf("The matrix will not converge\n");
     exit(1);
  }
}

/******************************************************/
/* compute_chunk_displacement() returns an array of integers,
 * indexed by "rank". It uses the array generated by
 * compute_size_array() to generate starting indices for each
 * process from 0 to numProc.
 * Example: Data Size = 10        INPUT
 *          Num Proc  = 4         INPUT
 *          Sizes     = 3 3 2 2   INPUT
 *          Offsets   = 0 3 6 8   OUTPUT
 */
int* compute_chunk_displacement(int matrixSize, int numProc, int *sizes, int matrix)
{
  int *displaceArray = (int *) malloc(numProc * sizeof(int));
  int i;
  displaceArray[0] = 0;
  for (i=1;i<numProc;i++) {
    if (sizes[i] > 0) {
      if (matrix) displaceArray[i] = displaceArray[i-1] + (sizes[i-1]);
      else displaceArray[i] = displaceArray[i-1]+sizes[i-1];
    } else {
      displaceArray[i] = -1;
    }
  }

  return displaceArray;
}

/******************************************************/
/* compute_size_array() returns an array of integers, indexed
 * by "rank". If (num % numProc != 0), it will distribute the
 * remainder, (num % numProc), adding 1 to the size of the first
 * (num % numProc) processes.
 */
int* compute_size_array(int matrixSize, int numProc, int matrix)
{
  int *sizes = (int *) malloc(numProc * sizeof(int));

  int divis = matrixSize / numProc;
  int modul = matrixSize % numProc;

  int iRank;
  for (iRank=0;iRank<numProc;iRank++) {
    if (iRank <= modul - 1) 
      sizes[iRank] = ((iRank * divis + iRank + divis + 1) - (iRank * divis + iRank));
    else
      sizes[iRank] = ((iRank * divis + divis + modul) - (iRank * divis + modul));
  }

  if (matrix) {
    for (iRank = 0;iRank < numProc;iRank++) sizes[iRank] = sizes[iRank] * matrixSize;
  }

  return sizes;
}

/******************************************************/
/* calculate_error() uses a distance function (detailed
 * on the Wikipedia entry for Jacobi algorithm) and returns
 * the current error using xOld and xNew.
 */
float calculate_error(float *xOld, float *xNew, int num) {
  int i;

  float totalError = 0;
  for (i=0;i<num;i++) totalError += (xNew[i] - xOld[i]) * (xNew[i] - xOld[i]);
  return totalError;
}

/******************************************************/
/* Read input from file */
void get_input(char filename[])
{
  FILE * fp;
  int i,j;  
 
  fp = fopen(filename, "r");
  if(!fp)
  {
    printf("Cannot open file %s\n", filename);
    exit(1);
  }

 fscanf(fp,"%d ",&num);
 fscanf(fp,"%f ",&err);

 /* Now, time to allocate the matrices and vectors */
 a = (float**)malloc(num * sizeof(float*));
 if( !a)
  {
	printf("Cannot allocate a!\n");
	exit(1);
  }

 for(i = 0; i < num; i++) 
  {
    a[i] = (float *)malloc(num * sizeof(float)); 
    if( !a[i])
  	{
		printf("Cannot allocate a[%d]!\n",i);
		exit(1);
  	}
  }

 //added code for contiguous A
 contiguousA = (float *) malloc(num * num * sizeof(float));
 
 x = (float *) malloc(num * sizeof(float));
 if( !x)
  {
	printf("Cannot allocate x!\n");
	exit(1);
  }


 b = (float *) malloc(num * sizeof(float));
 if( !b)
  {
	printf("Cannot allocate b!\n");
	exit(1);
  }

 /* Now .. Filling the blanks */ 

 /* The initial values of Xs */
 for(i = 0; i < num; i++)
	fscanf(fp,"%f ", &x[i]);
 
 for(i = 0; i < num; i++)
 {
   for(j = 0; j < num; j++)
     {
     fscanf(fp,"%f ",&a[i][j]);
     contiguousA[i*num + j] = a[i][j];
     }
   
   /* reading the b element */
   fscanf(fp,"%f ",&b[i]);
 }
 
 fclose(fp); 

}


/************************************************************/


int main(int argc, char *argv[])
{
 int i,j;
 int nit = 0; /* number of iterations */

  
 if( argc != 2)
 {
   printf("Usage: gsref filename\n");
   exit(1);
 }
  
 /* Read the input file and fill the global data structure above */ 
 get_input(argv[1]);
 
 /* Check for convergence condition */
 check_matrix();

 //init MPI
 int rank,numProc;
 MPI_Init(&argc, &argv);
 MPI_Comm_size(MPI_COMM_WORLD, &numProc);
 MPI_Comm_rank(MPI_COMM_WORLD, &rank);

 // Printf for testing contiguousA array.
 if (rank == 0 & VERBOSE)
 {
   for (i=0;i<num;i++)
   {
    for (j=0;j<num;j++) printf("%f ",contiguousA[i*num + j]);
    printf("\n");
   }
 }

 int rowsPerProc = num/numProc;

 /* Calculate sizes of data segments to MPI_Scatterv
  * between processes. Also, calculate steps between
  * starting indices.
  */
 int *sizeA = (int *) malloc(numProc * sizeof(int));
 int *sizeB = (int *) malloc(numProc * sizeof(int));
 int *stepA = (int *) malloc(numProc * sizeof(int));
 int *stepB = (int *) malloc(numProc * sizeof(int));

 sizeA = compute_size_array(num,numProc,1);
 sizeB = compute_size_array(num,numProc,0);
 stepA = compute_chunk_displacement(num,numProc,sizeA,1);
 stepB = compute_chunk_displacement(num,numProc,sizeB,0);

 // Initialize local arrays.
 float *local_x = (float *) malloc(sizeB[rank] * sizeof(float));
 float *local_b = (float *) malloc(sizeB[rank] * sizeof(float));
 float *local_a = (float *) malloc(sizeB[rank] * num * sizeof(float));

 //print statements for testing disabled
 if (rank == 0 && VERBOSE) {
  int k;
   printf("\nInput matrix \'a\':\n");
   for (i=0;i<num;i++) {
    printf("   ");
    for (k=0;k<num;k++) {
      printf("%f ",contiguousA[i*num + k]);
    }
    printf("     b=%f\n",b[i]);
   }
   printf("\n");
   for (i=0;i<numProc;i++) printf("Proc #%d: a_size=%d, a_offset=%d, b_size=%d, b_offset=%d\n",i,sizeA[i],stepA[i],sizeB[i],stepB[i]);
   printf("\n");
 }

 //scatter unequal parts
 MPI_Scatterv(contiguousA, sizeA,stepA, MPI_FLOAT, local_a, sizeA[rank], MPI_FLOAT, 0, MPI_COMM_WORLD);
 MPI_Scatterv(b, sizeB,stepB, MPI_FLOAT, local_b, sizeB[rank], MPI_FLOAT, 0, MPI_COMM_WORLD);
 MPI_Scatterv(x, sizeB,stepB, MPI_FLOAT, local_x, sizeB[rank], MPI_FLOAT, 0, MPI_COMM_WORLD);


 //-------------PRINT INITIALS----------------------
 if (VERBOSE) {
   printf("Proc #%d : \n",rank);
   for (i=0;i<sizeB[rank];i++)
   {
    printf("   ");
    for (j=0;j<num;j++) printf("%.2f ",local_a[i*num + j]);
    printf(" | initial_x = %.2f, local_b = %.2f, err = %.2f\n",local_x[i],local_b[i],err);
   }
   printf("\n");
 }
 //--------------------------------------------------

 /* JACOBI HERE */

 float *xNew = (float *) malloc(num * sizeof(float));
 float *xOld = (float *) malloc(num * sizeof(float));

 float totalError;

 MPI_Allgatherv(local_x,sizeB[rank],MPI_FLOAT,xNew,sizeB,stepB,MPI_FLOAT,MPI_COMM_WORLD);

 int iterations = 0;
 do
 {
    iterations++;

    // Set xOld = xNew
    for (i=0;i<num;i++)
    {
      xOld[i] = xNew[i];
    }

    /* Because of the way this algorithms splits up the equations,
     * sizeB[0] will always contain the largest number of equations
     * even if all processes receive the same number of equations.
     */ 
    for (i=0;i<sizeB[0];i++)
    {
      /* We now check that the actual equation in question is within the
       * domain of THIS process. If it is not, just skip all calculation
       * and jump directly to the MPI_Allgatherv
       *
       * This is NECESSARY, otherwise, we deadlock, since all processes in
       * MPI_COMM_WORLD must execute the MPI_Allgatherv so as not to block
       * process execution.
       */
      if (i < sizeB[rank]) {
        local_x[i] = local_b[i];

        for (j=0;j<stepB[rank]+i;j++) local_x[i] = local_x[i] - (xOld[j] * local_a[(i*num) + j]);
        for (j=stepB[rank]+i+1;j<num;j++) local_x[i] = local_x[i] - (xOld[j] * local_a[(i*num) + j]);

        local_x[i] = local_x[i] / local_a[(i*num) + (stepB[rank]+i)];
      }

      MPI_Allgatherv(local_x,sizeB[rank],MPI_FLOAT,xNew,sizeB,stepB,MPI_FLOAT,MPI_COMM_WORLD);

    }

 } while (calculate_error(xOld,xNew,num) >= err);
 
 MPI_Allgatherv(local_x,sizeB[rank],MPI_FLOAT,xNew,sizeB,stepB,MPI_FLOAT,MPI_COMM_WORLD);
 /* END JACOBI */

 /* Writing to the stdout */
 /* Keep that same format */
 if (rank == 0) {
  for( i = 0; i < num; i++)
     printf("%f\n",xNew[i]);
 
  printf("total number of iterations: %d\n", iterations);
 }

 MPI_Finalize();
 exit(0);
}
